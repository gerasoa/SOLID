<!-- https://docs.github.com/pt/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax -->

![Descrição da imagem](caminho/para/a/imagem.png)

# SOLID
### SOLID Principles Examples Repository

Welcome to the SOLID Principles Examples repository! This collection of code samples and demonstrations is designed to help developers understand and apply the SOLID principles in their software design. Dive into these practical examples to enhance your knowledge of Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion principles. Explore how to write clean, maintainable code that adapts and scales effortlessly.

For more information on the `SOLID` principles, visit the official SOLID principles website at https://solidprinciples.com/.

Hello world
```

<h> Hello world </h>

```

### 1 - Single Responsibility Principle (SRP)
This principle states that a class should have only one reason to change, meaning it should have only one responsibility or job. It helps to keep your classes focused and easier to understand.

### 2 - Open/Closed Principle (OCP)
The OCP encourages software entities (classes, modules, functions) to be open for extension but closed for modification. This means that you should be able to add new functionality without altering existing code. It promotes code reusability and minimizes the risk of introducing new bugs.

### 3 - Liskov Substitution Principle (LSP)
Named after Barbara Liskov, this principle states that objects of a derived class should be able to replace objects of the base class without affecting the correctness of the program. In other words, derived classes should extend, not break, the behavior of base classes.

### 4 - Interface Segregation Principle (ISP)
The ISP suggests that clients (users of an interface) should not be forced to depend on interfaces they do not use. It's better to have multiple small, specific interfaces rather than a large, monolithic one. This reduces the impact of changes and dependencies.

### 5 - Dependency Inversion Principle (DIP)
The DIP emphasizes high-level modules should not depend on low-level modules but should depend on abstractions. It also states that abstractions should not depend on details, and details should depend on abstractions. This encourages decoupling and promotes a more flexible, maintainable system.
